#!/usr/bin/env python3
"""
Test del Sistema de Navegaci√≥n Web REAL del Agente Mitosis
Evaluaci√≥n de la Fase 2 del NEWUPGRADE.md

Este test eval√∫a las capacidades REALES de navegaci√≥n web del sistema:
1. WebSearchTool con DuckDuckGo real
2. TavilySearchTool con API de Tavily real
3. Funcionalidad a trav√©s del endpoint /api/agent/chat
4. Evaluaci√≥n de limitaciones y necesidades de WebBrowserManager Playwright
"""

import requests
import json
import time
import os
import sys
from typing import Dict, Any, List
from datetime import datetime

# Configuraci√≥n
BACKEND_URL = "https://0eea585b-9491-4595-8054-818b778be2a7.preview.emergentagent.com"
API_BASE = f"{BACKEND_URL}/api"

class WebBrowsingTester:
    def __init__(self):
        self.results = {
            "test_timestamp": datetime.now().isoformat(),
            "backend_url": BACKEND_URL,
            "tests_performed": [],
            "web_search_tool": {"status": "unknown", "results": []},
            "tavily_search_tool": {"status": "unknown", "results": []},
            "chat_endpoint_web": {"status": "unknown", "results": []},
            "limitations_found": [],
            "recommendations": [],
            "phase_2_status": "unknown"
        }
        
    def log(self, message: str, level: str = "INFO"):
        """Log con timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
        
    def test_backend_health(self) -> bool:
        """Test b√°sico de conectividad del backend"""
        self.log("üîç Verificando conectividad del backend...")
        
        try:
            response = requests.get(f"{API_BASE}/health", timeout=10)
            if response.status_code == 200:
                data = response.json()
                self.log(f"‚úÖ Backend conectado: {data.get('status', 'unknown')}")
                return True
            else:
                self.log(f"‚ùå Backend no responde correctamente: {response.status_code}")
                return False
        except Exception as e:
            self.log(f"‚ùå Error conectando al backend: {e}")
            return False
    
    def test_websearch_tool_direct(self) -> Dict[str, Any]:
        """Test directo de WebSearchTool con DuckDuckGo"""
        self.log("üîç Testeando WebSearchTool con DuckDuckGo REAL...")
        
        test_result = {
            "tool_name": "WebSearchTool",
            "test_queries": [],
            "success_rate": 0,
            "avg_response_time": 0,
            "real_results_found": False,
            "errors": []
        }
        
        # Queries de test para evaluar capacidades reales
        test_queries = [
            "√∫ltimas noticias inteligencia artificial 2024",
            "tendencias tecnolog√≠a 2025",
            "Python programming best practices"
        ]
        
        successful_tests = 0
        total_time = 0
        
        for query in test_queries:
            self.log(f"  üîé Probando query: '{query}'")
            start_time = time.time()
            
            try:
                # Importar y usar directamente la herramienta
                sys.path.append('/app/backend/src/tools')
                from web_search_tool import WebSearchTool
                
                tool = WebSearchTool()
                result = tool.execute({
                    "query": query,
                    "action": "search",
                    "max_results": 5
                })
                
                response_time = time.time() - start_time
                total_time += response_time
                
                query_result = {
                    "query": query,
                    "response_time": response_time,
                    "success": result.get("success", False),
                    "results_count": len(result.get("results", [])),
                    "has_real_urls": False,
                    "sample_results": []
                }
                
                if result.get("success") and result.get("results"):
                    successful_tests += 1
                    
                    # Verificar que son resultados REALES
                    for res in result["results"][:2]:  # Tomar 2 ejemplos
                        url = res.get("url", "")
                        if url.startswith("http"):
                            query_result["has_real_urls"] = True
                            test_result["real_results_found"] = True
                        
                        query_result["sample_results"].append({
                            "title": res.get("title", "")[:100],
                            "url": url,
                            "snippet": res.get("snippet", "")[:150]
                        })
                    
                    self.log(f"    ‚úÖ Query exitosa: {len(result['results'])} resultados reales")
                else:
                    error_msg = result.get("error", "Unknown error")
                    query_result["error"] = error_msg
                    test_result["errors"].append(f"Query '{query}': {error_msg}")
                    self.log(f"    ‚ùå Query fall√≥: {error_msg}")
                
                test_result["test_queries"].append(query_result)
                
            except Exception as e:
                error_msg = str(e)
                test_result["errors"].append(f"Query '{query}': {error_msg}")
                self.log(f"    ‚ùå Error ejecutando query: {error_msg}")
                
                test_result["test_queries"].append({
                    "query": query,
                    "response_time": time.time() - start_time,
                    "success": False,
                    "error": error_msg
                })
        
        # Calcular m√©tricas
        test_result["success_rate"] = successful_tests / len(test_queries) if test_queries else 0
        test_result["avg_response_time"] = total_time / len(test_queries) if test_queries else 0
        
        self.log(f"üìä WebSearchTool - Tasa de √©xito: {test_result['success_rate']:.1%}, Tiempo promedio: {test_result['avg_response_time']:.2f}s")
        
        return test_result
    
    def test_tavily_search_tool_direct(self) -> Dict[str, Any]:
        """Test directo de TavilySearchTool con API real"""
        self.log("üîç Testeando TavilySearchTool con API de Tavily REAL...")
        
        test_result = {
            "tool_name": "TavilySearchTool",
            "test_queries": [],
            "success_rate": 0,
            "avg_response_time": 0,
            "real_results_found": False,
            "api_key_configured": False,
            "errors": []
        }
        
        try:
            # Verificar si la API key est√° configurada
            sys.path.append('/app/backend/src/tools')
            from tavily_search_tool import TavilySearchTool
            
            tool = TavilySearchTool()
            test_result["api_key_configured"] = tool.api_key is not None
            
            if not test_result["api_key_configured"]:
                self.log("‚ö†Ô∏è  API key de Tavily no configurada")
                test_result["errors"].append("Tavily API key not configured")
                return test_result
            
            # Queries de test
            test_queries = [
                "artificial intelligence trends 2024",
                "latest technology news",
                "Python programming tutorials"
            ]
            
            successful_tests = 0
            total_time = 0
            
            for query in test_queries:
                self.log(f"  üîé Probando query Tavily: '{query}'")
                start_time = time.time()
                
                try:
                    result = tool.execute({
                        "query": query,
                        "max_results": 5,
                        "include_answer": True
                    })
                    
                    response_time = time.time() - start_time
                    total_time += response_time
                    
                    query_result = {
                        "query": query,
                        "response_time": response_time,
                        "success": result.get("success", False),
                        "results_count": len(result.get("results", [])),
                        "has_answer": bool(result.get("answer", "")),
                        "has_real_urls": False,
                        "sample_results": []
                    }
                    
                    if result.get("success") and result.get("results"):
                        successful_tests += 1
                        
                        # Verificar que son resultados REALES
                        for res in result["results"][:2]:
                            url = res.get("url", "")
                            if url.startswith("http"):
                                query_result["has_real_urls"] = True
                                test_result["real_results_found"] = True
                            
                            query_result["sample_results"].append({
                                "title": res.get("title", "")[:100],
                                "url": url,
                                "snippet": res.get("snippet", "")[:150],
                                "score": res.get("score", 0)
                            })
                        
                        self.log(f"    ‚úÖ Query Tavily exitosa: {len(result['results'])} resultados, answer: {bool(result.get('answer'))}")
                    else:
                        error_msg = result.get("error", "Unknown error")
                        query_result["error"] = error_msg
                        test_result["errors"].append(f"Query '{query}': {error_msg}")
                        self.log(f"    ‚ùå Query Tavily fall√≥: {error_msg}")
                    
                    test_result["test_queries"].append(query_result)
                    
                except Exception as e:
                    error_msg = str(e)
                    test_result["errors"].append(f"Query '{query}': {error_msg}")
                    self.log(f"    ‚ùå Error ejecutando query Tavily: {error_msg}")
                    
                    test_result["test_queries"].append({
                        "query": query,
                        "response_time": time.time() - start_time,
                        "success": False,
                        "error": error_msg
                    })
            
            # Calcular m√©tricas
            test_result["success_rate"] = successful_tests / len(test_queries) if test_queries else 0
            test_result["avg_response_time"] = total_time / len(test_queries) if test_queries else 0
            
            self.log(f"üìä TavilySearchTool - Tasa de √©xito: {test_result['success_rate']:.1%}, Tiempo promedio: {test_result['avg_response_time']:.2f}s")
            
        except Exception as e:
            error_msg = str(e)
            test_result["errors"].append(f"Tool initialization error: {error_msg}")
            self.log(f"‚ùå Error inicializando TavilySearchTool: {error_msg}")
        
        return test_result
    
    def test_chat_endpoint_web_queries(self) -> Dict[str, Any]:
        """Test del endpoint /api/agent/chat con queries que requieren b√∫squeda web"""
        self.log("üîç Testeando endpoint /api/agent/chat con queries de b√∫squeda web...")
        
        test_result = {
            "endpoint": "/api/agent/chat",
            "test_messages": [],
            "success_rate": 0,
            "avg_response_time": 0,
            "web_tools_triggered": False,
            "autonomous_execution": False,
            "errors": []
        }
        
        # Mensajes que deber√≠an activar b√∫squeda web
        test_messages = [
            "¬øCu√°les son las √∫ltimas noticias sobre inteligencia artificial en 2024?",
            "Busca informaci√≥n sobre las tendencias tecnol√≥gicas m√°s importantes de 2025",
            "Investiga qu√© empresas est√°n liderando el desarrollo de IA generativa"
        ]
        
        successful_tests = 0
        total_time = 0
        
        for message in test_messages:
            self.log(f"  üí¨ Probando mensaje: '{message[:50]}...'")
            start_time = time.time()
            
            try:
                response = requests.post(
                    f"{API_BASE}/agent/chat",
                    json={"message": message},
                    timeout=30
                )
                
                response_time = time.time() - start_time
                total_time += response_time
                
                message_result = {
                    "message": message,
                    "response_time": response_time,
                    "status_code": response.status_code,
                    "success": response.status_code == 200,
                    "autonomous_execution": False,
                    "web_search_mentioned": False,
                    "response_length": 0
                }
                
                if response.status_code == 200:
                    data = response.json()
                    response_text = data.get("response", "")
                    message_result["response_length"] = len(response_text)
                    message_result["autonomous_execution"] = data.get("autonomous_execution", False)
                    
                    # Verificar si menciona b√∫squeda web o herramientas
                    web_keywords = ["b√∫squeda", "search", "web", "internet", "informaci√≥n", "investigar"]
                    if any(keyword in response_text.lower() for keyword in web_keywords):
                        message_result["web_search_mentioned"] = True
                        test_result["web_tools_triggered"] = True
                    
                    if message_result["autonomous_execution"]:
                        test_result["autonomous_execution"] = True
                    
                    successful_tests += 1
                    self.log(f"    ‚úÖ Mensaje procesado: {len(response_text)} chars, aut√≥nomo: {message_result['autonomous_execution']}")
                else:
                    error_msg = f"HTTP {response.status_code}"
                    message_result["error"] = error_msg
                    test_result["errors"].append(f"Message '{message[:30]}...': {error_msg}")
                    self.log(f"    ‚ùå Error HTTP: {response.status_code}")
                
                test_result["test_messages"].append(message_result)
                
            except Exception as e:
                error_msg = str(e)
                test_result["errors"].append(f"Message '{message[:30]}...': {error_msg}")
                self.log(f"    ‚ùå Error procesando mensaje: {error_msg}")
                
                test_result["test_messages"].append({
                    "message": message,
                    "response_time": time.time() - start_time,
                    "success": False,
                    "error": error_msg
                })
        
        # Calcular m√©tricas
        test_result["success_rate"] = successful_tests / len(test_messages) if test_messages else 0
        test_result["avg_response_time"] = total_time / len(test_messages) if test_messages else 0
        
        self.log(f"üìä Chat Endpoint - Tasa de √©xito: {test_result['success_rate']:.1%}, Tiempo promedio: {test_result['avg_response_time']:.2f}s")
        
        return test_result
    
    def evaluate_limitations(self, websearch_result: Dict, tavily_result: Dict, chat_result: Dict):
        """Evaluar limitaciones del sistema actual"""
        self.log("üîç Evaluando limitaciones del sistema de navegaci√≥n web...")
        
        limitations = []
        
        # Evaluar WebSearchTool
        if websearch_result["success_rate"] < 0.8:
            limitations.append({
                "component": "WebSearchTool",
                "issue": "Baja tasa de √©xito en b√∫squedas",
                "impact": "B√∫squedas web poco confiables",
                "severity": "high"
            })
        
        if not websearch_result["real_results_found"]:
            limitations.append({
                "component": "WebSearchTool", 
                "issue": "No se encontraron resultados reales con URLs v√°lidas",
                "impact": "Posibles resultados simulados o errores de parsing",
                "severity": "critical"
            })
        
        if websearch_result["avg_response_time"] > 10:
            limitations.append({
                "component": "WebSearchTool",
                "issue": "Tiempo de respuesta lento",
                "impact": "Experiencia de usuario degradada",
                "severity": "medium"
            })
        
        # Evaluar TavilySearchTool
        if not tavily_result["api_key_configured"]:
            limitations.append({
                "component": "TavilySearchTool",
                "issue": "API key no configurada",
                "impact": "Herramienta de b√∫squeda avanzada no disponible",
                "severity": "high"
            })
        
        if tavily_result["success_rate"] < 0.8:
            limitations.append({
                "component": "TavilySearchTool",
                "issue": "Baja tasa de √©xito",
                "impact": "B√∫squedas avanzadas poco confiables",
                "severity": "high"
            })
        
        # Evaluar integraci√≥n con Chat
        if not chat_result["web_tools_triggered"]:
            limitations.append({
                "component": "Chat Integration",
                "issue": "Herramientas web no se activan autom√°ticamente",
                "impact": "B√∫squedas web no se ejecutan cuando se necesitan",
                "severity": "critical"
            })
        
        if not chat_result["autonomous_execution"]:
            limitations.append({
                "component": "Autonomous Execution",
                "issue": "Ejecuci√≥n aut√≥noma no se activa para b√∫squedas web",
                "impact": "Usuario debe activar manualmente las b√∫squedas",
                "severity": "medium"
            })
        
        # Limitaciones generales identificadas
        general_limitations = [
            {
                "component": "JavaScript Rendering",
                "issue": "Sin capacidad de ejecutar JavaScript",
                "impact": "Sitios web din√°micos no accesibles",
                "severity": "high"
            },
            {
                "component": "Interactive Navigation",
                "issue": "Sin navegaci√≥n interactiva (clicks, forms)",
                "impact": "Limitado a contenido est√°tico",
                "severity": "medium"
            },
            {
                "component": "Session Management",
                "issue": "Sin manejo de sesiones/cookies",
                "impact": "No puede acceder a contenido que requiere login",
                "severity": "medium"
            }
        ]
        
        limitations.extend(general_limitations)
        
        self.results["limitations_found"] = limitations
        
        # Log limitaciones encontradas
        critical_count = len([l for l in limitations if l["severity"] == "critical"])
        high_count = len([l for l in limitations if l["severity"] == "high"])
        
        self.log(f"‚ö†Ô∏è  Limitaciones encontradas: {len(limitations)} total ({critical_count} cr√≠ticas, {high_count} altas)")
        
        for limitation in limitations:
            severity_emoji = "üî¥" if limitation["severity"] == "critical" else "üü†" if limitation["severity"] == "high" else "üü°"
            self.log(f"  {severity_emoji} {limitation['component']}: {limitation['issue']}")
    
    def generate_recommendations(self):
        """Generar recomendaciones basadas en los resultados"""
        self.log("üí° Generando recomendaciones...")
        
        recommendations = []
        
        # Analizar limitaciones cr√≠ticas
        critical_limitations = [l for l in self.results["limitations_found"] if l["severity"] == "critical"]
        
        if critical_limitations:
            recommendations.append({
                "priority": "high",
                "action": "Implementar WebBrowserManager con Playwright",
                "reason": "Limitaciones cr√≠ticas en navegaci√≥n web actual",
                "benefits": [
                    "Renderizado de JavaScript",
                    "Navegaci√≥n interactiva",
                    "Manejo de sesiones",
                    "Capturas de pantalla",
                    "Automatizaci√≥n completa"
                ]
            })
        
        # Recomendaciones espec√≠ficas por herramienta
        if not self.results["tavily_search_tool"]["api_key_configured"]:
            recommendations.append({
                "priority": "medium",
                "action": "Configurar API key de Tavily",
                "reason": "Herramienta de b√∫squeda avanzada no disponible",
                "benefits": ["B√∫squedas m√°s precisas", "Respuestas resumidas", "Mayor confiabilidad"]
            })
        
        if self.results["web_search_tool"]["success_rate"] < 0.8:
            recommendations.append({
                "priority": "medium", 
                "action": "Mejorar robustez de WebSearchTool",
                "reason": "Baja tasa de √©xito en b√∫squedas b√°sicas",
                "benefits": ["Mayor confiabilidad", "Mejor experiencia de usuario"]
            })
        
        if not self.results["chat_endpoint_web"]["web_tools_triggered"]:
            recommendations.append({
                "priority": "high",
                "action": "Mejorar integraci√≥n de herramientas web en chat",
                "reason": "Herramientas web no se activan autom√°ticamente",
                "benefits": ["Experiencia m√°s fluida", "Automatizaci√≥n real"]
            })
        
        # Recomendaciones de mejora general
        recommendations.append({
            "priority": "low",
            "action": "Implementar cache de resultados web",
            "reason": "Optimizar rendimiento y reducir llamadas API",
            "benefits": ["Mejor rendimiento", "Reducci√≥n de costos", "Experiencia m√°s r√°pida"]
        })
        
        recommendations.append({
            "priority": "medium",
            "action": "A√±adir m√©tricas de calidad de resultados",
            "reason": "Evaluar autom√°ticamente la relevancia de resultados",
            "benefits": ["Mejor calidad", "Detecci√≥n autom√°tica de problemas"]
        })
        
        self.results["recommendations"] = recommendations
        
        # Log recomendaciones
        high_priority = len([r for r in recommendations if r["priority"] == "high"])
        self.log(f"üí° Recomendaciones generadas: {len(recommendations)} total ({high_priority} alta prioridad)")
    
    def determine_phase_2_status(self):
        """Determinar el estado de la Fase 2 del NEWUPGRADE.md"""
        self.log("üìä Determinando estado de la Fase 2 del NEWUPGRADE.md...")
        
        # Criterios para evaluar la Fase 2
        websearch_working = self.results["web_search_tool"]["success_rate"] >= 0.7
        tavily_available = self.results["tavily_search_tool"]["api_key_configured"]
        tavily_working = self.results["tavily_search_tool"]["success_rate"] >= 0.7 if tavily_available else False
        chat_integration = self.results["chat_endpoint_web"]["success_rate"] >= 0.7
        real_results = (self.results["web_search_tool"]["real_results_found"] or 
                       self.results["tavily_search_tool"]["real_results_found"])
        
        critical_limitations = len([l for l in self.results["limitations_found"] if l["severity"] == "critical"])
        
        # Determinar estado
        if websearch_working and real_results and chat_integration and critical_limitations == 0:
            status = "COMPLETAMENTE_EXITOSA"
            description = "Sistema de navegaci√≥n web completamente funcional con herramientas reales"
        elif websearch_working and real_results and critical_limitations <= 1:
            status = "PARCIALMENTE_EXITOSA"
            description = "Sistema funcional con limitaciones menores"
        elif websearch_working or tavily_working:
            status = "FUNCIONAL_CON_LIMITACIONES"
            description = "Algunas herramientas funcionan pero hay limitaciones significativas"
        else:
            status = "NECESITA_MEJORAS"
            description = "Sistema requiere mejoras significativas para ser funcional"
        
        self.results["phase_2_status"] = status
        self.results["phase_2_description"] = description
        
        # Determinar si WebBrowserManager Playwright es necesario
        playwright_needed = critical_limitations > 0 or not chat_integration
        self.results["playwright_needed"] = playwright_needed
        
        status_emoji = "‚úÖ" if status == "COMPLETAMENTE_EXITOSA" else "üü°" if "PARCIAL" in status else "‚ö†Ô∏è" if "FUNCIONAL" in status else "‚ùå"
        self.log(f"{status_emoji} Estado Fase 2: {status}")
        self.log(f"üìù Descripci√≥n: {description}")
        self.log(f"üé≠ WebBrowserManager Playwright necesario: {'S√≠' if playwright_needed else 'No'}")
    
    def run_comprehensive_test(self):
        """Ejecutar test comprensivo del sistema de navegaci√≥n web"""
        self.log("üöÄ Iniciando test comprensivo del sistema de navegaci√≥n web REAL...")
        self.log(f"üéØ Objetivo: Evaluar estado de Fase 2 del NEWUPGRADE.md")
        self.log(f"üåê Backend URL: {BACKEND_URL}")
        
        # 1. Verificar conectividad
        if not self.test_backend_health():
            self.log("‚ùå No se puede continuar sin conectividad al backend")
            return self.results
        
        # 2. Test WebSearchTool directo
        self.results["web_search_tool"] = self.test_websearch_tool_direct()
        self.results["tests_performed"].append("WebSearchTool Direct Test")
        
        # 3. Test TavilySearchTool directo
        self.results["tavily_search_tool"] = self.test_tavily_search_tool_direct()
        self.results["tests_performed"].append("TavilySearchTool Direct Test")
        
        # 4. Test endpoint chat con queries web
        self.results["chat_endpoint_web"] = self.test_chat_endpoint_web_queries()
        self.results["tests_performed"].append("Chat Endpoint Web Queries Test")
        
        # 5. Evaluar limitaciones
        self.evaluate_limitations(
            self.results["web_search_tool"],
            self.results["tavily_search_tool"], 
            self.results["chat_endpoint_web"]
        )
        
        # 6. Generar recomendaciones
        self.generate_recommendations()
        
        # 7. Determinar estado de Fase 2
        self.determine_phase_2_status()
        
        self.log("‚úÖ Test comprensivo completado")
        return self.results
    
    def save_results(self, filename: str = "web_browsing_test_results.json"):
        """Guardar resultados en archivo JSON"""
        try:
            with open(f"/app/{filename}", 'w', encoding='utf-8') as f:
                json.dump(self.results, f, indent=2, ensure_ascii=False, default=str)
            self.log(f"üíæ Resultados guardados en: /app/{filename}")
        except Exception as e:
            self.log(f"‚ùå Error guardando resultados: {e}")
    
    def print_summary(self):
        """Imprimir resumen de resultados"""
        self.log("\n" + "="*80)
        self.log("üìä RESUMEN DE RESULTADOS - SISTEMA DE NAVEGACI√ìN WEB REAL")
        self.log("="*80)
        
        # Estado general
        status = self.results["phase_2_status"]
        status_emoji = "‚úÖ" if status == "COMPLETAMENTE_EXITOSA" else "üü°" if "PARCIAL" in status else "‚ö†Ô∏è" if "FUNCIONAL" in status else "‚ùå"
        self.log(f"\n{status_emoji} ESTADO FASE 2 NEWUPGRADE.MD: {status}")
        self.log(f"üìù {self.results['phase_2_description']}")
        
        # Resultados por herramienta
        self.log(f"\nüîç WEBSEARCHTOOL (DuckDuckGo):")
        ws = self.results["web_search_tool"]
        self.log(f"   Tasa de √©xito: {ws['success_rate']:.1%}")
        self.log(f"   Resultados reales: {'‚úÖ' if ws['real_results_found'] else '‚ùå'}")
        self.log(f"   Tiempo promedio: {ws['avg_response_time']:.2f}s")
        
        self.log(f"\nüéØ TAVILYSEARCHTOOL (API Tavily):")
        ts = self.results["tavily_search_tool"]
        self.log(f"   API configurada: {'‚úÖ' if ts['api_key_configured'] else '‚ùå'}")
        self.log(f"   Tasa de √©xito: {ts['success_rate']:.1%}")
        self.log(f"   Resultados reales: {'‚úÖ' if ts['real_results_found'] else '‚ùå'}")
        
        self.log(f"\nüí¨ INTEGRACI√ìN CHAT:")
        cs = self.results["chat_endpoint_web"]
        self.log(f"   Tasa de √©xito: {cs['success_rate']:.1%}")
        self.log(f"   Herramientas web activadas: {'‚úÖ' if cs['web_tools_triggered'] else '‚ùå'}")
        self.log(f"   Ejecuci√≥n aut√≥noma: {'‚úÖ' if cs['autonomous_execution'] else '‚ùå'}")
        
        # Limitaciones cr√≠ticas
        critical = [l for l in self.results["limitations_found"] if l["severity"] == "critical"]
        self.log(f"\nüî¥ LIMITACIONES CR√çTICAS: {len(critical)}")
        for limitation in critical:
            self.log(f"   ‚Ä¢ {limitation['component']}: {limitation['issue']}")
        
        # Recomendaci√≥n principal
        self.log(f"\nüí° RECOMENDACI√ìN PRINCIPAL:")
        if self.results["playwright_needed"]:
            self.log("   üé≠ IMPLEMENTAR WebBrowserManager con Playwright")
            self.log("   üìã Raz√≥n: Limitaciones cr√≠ticas en navegaci√≥n web actual")
        else:
            self.log("   ‚úÖ Sistema actual es suficiente para objetivos b√°sicos")
            self.log("   üìã Considerar mejoras menores para optimizaci√≥n")
        
        self.log("\n" + "="*80)

def main():
    """Funci√≥n principal"""
    print("üß™ SISTEMA DE TESTING DE NAVEGACI√ìN WEB REAL - MITOSIS AGENT")
    print("üìã Evaluaci√≥n de Fase 2 del NEWUPGRADE.md")
    print("="*80)
    
    # Crear tester y ejecutar
    tester = WebBrowsingTester()
    results = tester.run_comprehensive_test()
    
    # Guardar y mostrar resultados
    tester.save_results()
    tester.print_summary()
    
    return results

if __name__ == "__main__":
    main()